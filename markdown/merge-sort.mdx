| Complexity              | Value                  |
| ----------------------- | ---------------------- |
| Space Complexity        | $$\text{O}(n)$$        |
| Average Time Complexity | $$\text{O}(n\log{n})$$ |
| Best Time Complexity    | $$\text{O}(n\log{n})$$ |
| Worst Time Complexity   | $$\text{O}(n\log{n})$$ |

A **stable** sorting algorithm that follows the divide-and-conquer approach. It works by recursively dividing the input array into smaller subarrays and sorting those subarrays then merging them back together to obtain the sorted array.

<img src="/images/sort/merge-sort/IMG_0043.JPG" alt="insertion-sort" />

The step involved are

###### Divide
A merge sort works recursively. First it divides a data set in half, and sorts each half separately.

###### Merge
The sorted sub-arrays are merged back together in sorted order.
1. The first elements from each of the two lists are compared.
2. The lesser element is then removed from its list and added to the final result list.



Each recursive call has `O(n)` runtime, and a total of `O(log n)` recursions are required, thus **the runtime of this algorithm is** `O(n * log n)`. A merge sort can also be modified for performance on lists that are nearly sorted to begin with. After sorting each half of the data, if the highest element in one list is less than the lowest element in the other half, then the merge step is unnecessary.

> üí° Apart from being fairly efficient, a merge sort has the advantage that it can be used to solve other problems, such as determining how ‚Äúunsorted‚Äù a given list is.

Merge sort is not an in-place sorting algorithm, which means it requires additional memory to store the sorted data. This can be a disadvantage in applications where memory usage is a concern.

## Key Points

- can independently merge subarrays that makes it suitable for parallel processing.
- Supports External sorting (when the dataset is too large to fit in memory)
- Can be modified to count the inversion
- a preferred algorithm for sorting Linked lists.
- quickSort is more cache friendly because it works in-place.
